Index: lab_2/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport math\r\nimport os\r\n\r\nfrom mpmath import gammainc\r\nfrom scipy.special import erfc\r\nfrom constants import PATH, LENGTH_OF_BLOCK, PI_I\r\n\r\n\r\ndef read_json_file(file_path: str) -> dict:\r\n    \"\"\"\r\n    Функция считывает данные из JSON файла.\r\n    :param file_path: указывает на расположение JSON файла.\r\n    :return dict:\r\n    \"\"\"\r\n    try:\r\n        with open(file_path, \"r\", encoding=\"UTF-8\") as file:\r\n            json_data = json.load(file)\r\n            return json_data\r\n    except FileNotFoundError:\r\n        print(\"Файл не найден.\")\r\n        raise\r\n    except json.JSONDecodeError:\r\n        print(\"Ошибка при считывании JSON-данных.\")\r\n        raise\r\n    except Exception as e:\r\n        print(f\"Произошла ошибка: {e}\")\r\n        raise\r\n\r\n\r\ndef frequency_bitwise_test(sequence: str) -> float:\r\n    \"\"\"\r\n    Функция принимает последовательность бит в виде строки,\r\n    а затем рассчитывает P-значение для частотного побитового теста\r\n    и возвращает его.\r\n    :param sequence: последовательность бит в виде строки(str).\r\n    :return float:\r\n    \"\"\"\r\n    try:\r\n        N = len(sequence)\r\n        sum = 0\r\n        for bit in sequence:\r\n            if bit == \"0\":\r\n                sum -= 1\r\n            else:\r\n                sum += 1\r\n        S_N = (1.0 / math.sqrt(N)) * abs(sum)\r\n        P_value = erfc(S_N / math.sqrt(2))\r\n        if P_value < 0 or P_value > 1:\r\n            raise ValueError('P should be in range [0, 1]')\r\n        return P_value\r\n    except Exception as e:\r\n        print(f\"Произошла ошибка: {e}\")\r\n        raise\r\n\r\n    return P_value\r\n\r\n\r\ndef similar_sequences_test(sequence: str) -> float:\r\n    \"\"\"\r\n    Функция принимает последовательность бит в виде строки,\r\n    а затем рассчитывает P-значение для теста на одинаковые подряд идущие биты\r\n    и возвращает его.\r\n    :param sequence: последовательность бит в виде строки(str).\r\n    :return float:\r\n    \"\"\"\r\n    try:\r\n        N = len(sequence)\r\n        sum = 0\r\n        for bit in sequence:\r\n            if bit == \"1\":\r\n                sum += 1\r\n        proportion_of_ones = sum / N\r\n        if abs(proportion_of_ones - (1 / 2)) < 2 / math.sqrt(N):\r\n            V_n = 0\r\n            for i in range(0, N - 1):\r\n                if (sequence[i] != sequence[i + 1]):\r\n                    V_n += 1\r\n            P_value = erfc(\r\n                abs(V_n - 2 * N * proportion_of_ones * (1 - proportion_of_ones)) / (\r\n                        2 * math.sqrt(2 * N) * proportion_of_ones * (\r\n                        1 - proportion_of_ones)))\r\n            if P_value < 0 or P_value > 1:\r\n                raise ValueError('P should be in range [0, 1]')\r\n            return P_value\r\n        else:\r\n            return 0\r\n    except Exception as e:\r\n        print(f\"Произошла ошибка: {e}\")\r\n        raise\r\n\r\n\r\ndef longest_ones_sequence_test(sequence: str):\r\n    \"\"\"\r\n    Функция принимает последовательность бит в виде строки,\r\n    а затем рассчитывает P-значение для теста на самую длинную\r\n    последовательность единиц в блоке и возвращает его.\r\n    :param sequence:  последовательность бит в виде строки(str).\r\n    :return float:\r\n    \"\"\"\r\n    try:\r\n        blocks = []\r\n        for i in range(0, int(len(sequence) / LENGTH_OF_BLOCK)):\r\n            blocks.append(sequence[i * LENGTH_OF_BLOCK: (i + 1) * LENGTH_OF_BLOCK])\r\n        V = [0, 0, 0, 0]\r\n        for block in blocks:\r\n            count = 0\r\n            max_length = 0\r\n            for bit in block:\r\n                if bit == \"1\":\r\n                    count += 1\r\n                    max_length = max(max_length, count)\r\n                else:\r\n                    count = 0\r\n            if max_length <= 1:\r\n                V[0] += 1\r\n            if max_length == 2:\r\n                V[1] += 1\r\n            if max_length == 3:\r\n                V[2] += 1\r\n            if max_length >= 4:\r\n                V[3] += 1\r\n        Xi_in_2 = 0\r\n        for i in range(0, 4):\r\n            Xi_in_2 += pow((V[i] - 16 * PI_I[i]), 2) / (16 * PI_I[i])\r\n        P_value = gammainc(1.5, (Xi_in_2 / 2))\r\n        if P_value < 0 or P_value > 1:\r\n            raise ValueError('P should be in range [0, 1]')\r\n        return P_value\r\n    except Exception as e:\r\n        print(f\"Произошла ошибка: {e}\")\r\n        raise\r\n\r\n\r\ndef main() -> None:\r\n    \"\"\"\r\n    Функция считывает из Json файла последовальности бит,\r\n    полученные из генераторов рандомных чисел C++, JAVA, Python.\r\n    Затем проводит тесты для каждого из них.\r\n    :param :\r\n    :return None:\r\n    \"\"\"\r\n    try:\r\n        absolute_path = os.path.abspath(os.getcwd())\r\n        json_data = read_json_file(absolute_path + PATH)\r\n        if json_data:\r\n            CPP_SEQUENCE = json_data.get(\"CPP\", \"\")\r\n            JAVA_SEQUENCE = json_data.get(\"JAVA\", \"\")\r\n            PYTHON_SEQUENCE = json_data.get(\"PYTHON\", \"\")\r\n        if CPP_SEQUENCE and JAVA_SEQUENCE and PYTHON_SEQUENCE:\r\n            print(\"Tests for CPP_SEQUENCE:\")\r\n            print(\"Frequency bitwise test: P = \" + str(frequency_bitwise_test(CPP_SEQUENCE)))\r\n            print(\"Similar sequences test: P = \" + str(similar_sequences_test(CPP_SEQUENCE)))\r\n            print(\"Longest ones sequence test: P = \" + str(longest_ones_sequence_test(CPP_SEQUENCE)))\r\n            print(\"Tests for JAVA_SEQUENCE:\")\r\n            print(\"Frequency bitwise test: P = \" + str(frequency_bitwise_test(JAVA_SEQUENCE)))\r\n            print(\"Similar sequences test: P = \" + str(similar_sequences_test(JAVA_SEQUENCE)))\r\n            print(\"Longest ones sequence test: P = \" + str(longest_ones_sequence_test(JAVA_SEQUENCE)))\r\n            print(\"Tests for PYTHON_SEQUENCE:\")\r\n            print(\"Frequency bitwise test: P = \" + str(frequency_bitwise_test(PYTHON_SEQUENCE)))\r\n            print(\"Similar sequences test: P = \" + str(similar_sequences_test(PYTHON_SEQUENCE)))\r\n            print(\"Longest ones sequence test: P = \" + str(longest_ones_sequence_test(PYTHON_SEQUENCE)))\r\n    except Exception as e:\r\n        print(f\"Произошла ошибка: {e}\")\r\n        raise\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
===================================================================
diff --git a/lab_2/main.py b/lab_2/main.py
--- a/lab_2/main.py	
+++ b/lab_2/main.py	
@@ -2,8 +2,9 @@
 import math
 import os
 
-from mpmath import gammainc
 from scipy.special import erfc
+from mpmath import gammainc
+
 from constants import PATH, LENGTH_OF_BLOCK, PI_I
 
 
